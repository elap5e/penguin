// Copyright 2022 Elapse and contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

type Message struct {
	Name    string     `json:"name,omitempty"`
	Note    string     `json:"note,omitempty"`
	Source  string     `json:"source,omitempty"`
	Length  int        `json:"length,omitempty"`
	Fields  []*Field   `json:"fields,omitempty"`
	Message []*Message `json:"message,omitempty"`
}

type Field struct {
	Code uint64 `json:"code,omitempty"`
	Name string `json:"name,omitempty"`
	Type string `json:"type,omitempty"`
	Note string `json:"note,omitempty"`
}

func main() {
	last, lastDir, merge := "", "", &Message{}
	filepath.Walk(".", func(file string, info os.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}
		if strings.HasSuffix(info.Name(), ".pb.java") {
			dir := path.Dir(file)
			dst := dir + "/" + strings.ReplaceAll(info.Name(), ".pb.java", ".proto")
			if i := strings.LastIndex(dst, "$"); i > 0 {
				dst = dst[:i] + ".proto"
			}
			if last == "" {
				last, lastDir = dst, dir
			}
			if last != dst {
				writeFile(last, lastDir, merge)
				last, lastDir, merge = dst, dir, &Message{}
			}
			data, err := ioutil.ReadFile(file)
			if err != nil {
				log.Fatalln(err)
			}
			lines := strings.Split(string(data), "\n")
			index := strings.Index(lines[0], "package")
			if index == -1 {
				log.Fatalln("package not found")
			}
			message, _ := parseMessage(index, lines)
			if len(message.Fields) == 0 && len(message.Message) == 1 {
				merge = message.Message[0]
				merge.Source = message.Source
			} else {
				if tmp := strings.Split(message.Note, "$"); len(tmp) > 1 {
					message = &Message{
						Name:    parseName(tmp[0]),
						Note:    tmp[0],
						Message: []*Message{message},
					}
				}
				merge.Name = message.Name
				merge.Note = message.Note
				merge.Source = message.Source
				merge.Fields = message.Fields
				merge.Message = append(merge.Message, message.Message...)
			}
		}
		return nil
	})
	writeFile(last, lastDir, merge)
}

func writeFile(dst, dir string, merge *Message) {
	if _, err := os.Stat(dst); !errors.Is(err, os.ErrNotExist) {
		return
	}
	buf := bytes.NewBuffer(nil)
	buf.WriteString("syntax = \"proto3\";\n")
	buf.WriteString("\n")
	buf.WriteString("option go_package = \"github.com/elap5e/penguin/" + dir + "\";\n")
	buf.WriteString("\n")
	writeMessage(buf, 0, merge)
	if err := ioutil.WriteFile(dst, buf.Bytes(), 0644); err != nil {
		log.Fatalln(dst)
	}
}

func writeMessage(buf *bytes.Buffer, index int, message *Message) {
	blank := strings.Repeat(" ", index)
	if message.Source != "" {
		buf.WriteString(blank + "// Message generated by proto-message-gen. DO NOT EDIT.\n")
		buf.WriteString(blank + "// source: " + message.Source + "." + message.Note + "\n")
		buf.WriteString(blank + "//\n")
	}
	buf.WriteString(blank + "// " + message.Name + " is the message type for the " + message.Note + ".\n")
	if len(message.Fields) != 0 || len(message.Message) != 0 {
		buf.WriteString(blank + "message " + message.Name + " {\n")
		for _, v := range message.Fields {
			format := fmt.Sprintf("%%s  %%-%ds = %%d; // %%s\n", message.Length)
			buf.WriteString(fmt.Sprintf(format, blank, v.Type+" "+v.Name, v.Code, v.Note))
		}
		for _, v := range message.Message {
			writeMessage(buf, index+2, v)
		}
		buf.WriteString(blank + "}\n")
	} else {
		buf.WriteString(blank + "message " + message.Name + " {}\n")
	}
}

func parseMessage(index int, lines []string) (*Message, int) {
	var line, name string
	var skip int64
	var msg *Message
	var codes map[string]uint64
	for i := 0; i < len(lines); i++ {
		if line = lines[i]; len(line) > index {
			line = strings.TrimSpace(line[index:])
			if strings.HasPrefix(line, "package") {
				name = strings.Split(line, " ")[1]
				name = name[:len(name)-1]
			} else if strings.HasPrefix(line, "public final class") ||
				strings.HasPrefix(line, "public static final class") {
				if msg == nil {
					msg = new(Message)
					msg.Note = strings.Split(line, " ")[3]
					if msg.Note == "class" {
						msg.Note = strings.Split(line, " ")[4]
					}
					msg.Name = parseName(msg.Note)
					msg.Source = name
				} else {
					emb, n := parseMessage(index, lines[i:])
					msg.Message = append(msg.Message, emb)
					i = i + n
				}
			} else if strings.HasPrefix(line, "static final MessageMicro.FieldMap __fieldMap__") {
				if line == "static final MessageMicro.FieldMap __fieldMap__;" {
					skip++
					for n := 0; !strings.HasPrefix(line, "__fieldMap__ ="); n++ {
						if line = lines[i+n]; len(line) > index {
							line = strings.TrimSpace(line[index:])
						}
					}
				}
				tmp := strings.Split(line, "(new int[]{")
				if len(tmp) == 1 {
					continue
				}
				tmp = strings.Split(tmp[1], "}, new String[]{")
				strs := strings.Split(tmp[0], ", ")
				tmp = strings.Split(tmp[1], "}, new Object[]{")
				codes = make(map[string]uint64)
				for k, v := range strings.Split(tmp[0], ", ") {
					codes[strings.ReplaceAll(v, "\"", "")], _ = strconv.ParseUint(strs[k], 10, 64)
				}
			} else if strings.HasPrefix(line, "public") {
				tmp := strings.Split(line, " ")[1:]
				if tmp[0] == "final" {
					tmp = tmp[1:]
				} else if strings.HasPrefix(tmp[4], "MessageMicro") {
					if msg == nil {
						msg = new(Message)
						msg.Note = tmp[0]
						msg.Name = parseName(msg.Note)
					} else {
						emb, n := parseMessage(index, lines[i:])
						msg.Message = append(msg.Message, emb)
						i = i + n
					}
				}
				if code := codes[tmp[1]]; code != 0 {
					field := parseField(code, tmp[1], tmp[0], line)
					msg.Fields = append(msg.Fields, field)
					length := len(field.Name) + len(field.Type) + 1
					if length > msg.Length {
						msg.Length = length
					}
				}
			} else if !strings.HasPrefix(line, "}") {
			} else if skip != 0 {
				skip--
			} else {
				return msg, i
			}
		}
	}
	return msg, 0
}

func parseName(name string) string {
	if i := strings.LastIndex(name, "$"); i > 0 {
		return name[i+1:]
	}
	return name
}

func parseType(typ string, line string) string {
	if typ == "PBBoolField" {
		typ = "bool"
	} else if typ == "PBBytesField" {
		typ = "bytes"
	} else if typ == "PBEnumField" {
		typ = "int32"
	} else if typ == "PBFixed32Field" {
		typ = "fixed32"
	} else if typ == "PBFixed64Field" {
		typ = "fixed64"
	} else if typ == "PBFloatField" {
		typ = "float"
	} else if typ == "PBDoubleField" {
		typ = "double"
	} else if typ == "PBInt32Field" {
		typ = "int32"
	} else if typ == "PBInt32Field" {
		typ = "int32"
	} else if typ == "PBSInt32Field" {
		typ = "sint32"
	} else if typ == "PBSInt32Field" {
		typ = "sint32"
	} else if typ == "PBStringField" {
		typ = "string"
	} else if typ == "PBUInt32Field" {
		typ = "uint32"
	} else if typ == "PBUInt64Field" {
		typ = "uint64"
	} else if strings.HasPrefix(typ, "PBRepeatField<") {
		re, _ := regexp.Compile("PBRepeatField<(.*)>")
		switch tmp := re.FindStringSubmatch(typ)[1]; tmp {
		case "ByteStringMicro":
			typ = "bytes"
		case "Integer":
			typ = "uint32"
		case "Float":
			typ = "float"
		case "Double":
			typ = "double"
		case "Long":
			typ = "uint64"
		case "String":
			typ = "string"
		}
		typ = "repeated " + parseName(typ)
	} else if strings.HasPrefix(typ, "PBRepeatField") {
		re, _ := regexp.Compile("initRepeat\\((.*)\\.")
		typ = "repeated " + parseType(re.FindStringSubmatch(line)[1], line)
	} else if strings.HasPrefix(typ, "PBRepeatMessageField<") {
		re, _ := regexp.Compile("PBRepeatMessageField<(.*)>")
		typ = "repeated " + parseName(re.FindStringSubmatch(typ)[1])
	} else if strings.HasPrefix(typ, "PBRepeatMessageField") {
		re, _ := regexp.Compile("initRepeatMessage\\((.*)\\.")
		typ = "repeated " + parseType(re.FindStringSubmatch(line)[1], line)
	} else {
		typ = parseName(typ)
	}
	return typ
}

func parseField(code uint64, name, typ, line string) *Field {
	note := name
	strs := strings.Split(parseName(name), "_")
	typ = parseType(typ, line)
	for {
		if len(strs) == 1 {
			break
		}
		if strs[0] == "" ||
			strs[0] == "bool" ||
			strs[0] == "bytes" ||
			strs[0] == "float" ||
			strs[0] == "double" ||
			strs[0] == "fixed32" ||
			strs[0] == "fixed64" ||
			strs[0] == "int32" ||
			strs[0] == "int64" ||
			strs[0] == "rpt" ||
			strs[0] == "str" ||
			strs[0] == "string" ||
			strs[0] == "sint32" ||
			strs[0] == "sint64" ||
			strs[0] == "uint32" ||
			strs[0] == "uint64" {
			strs = strs[1:]
		} else if strs[0] == "opt" {
			typ = "optional " + typ
			strs = strs[1:]
		} else {
			break
		}
	}
	name = strings.Join(strs, "_")
	return &Field{
		Code: code >> 3,
		Name: name,
		Type: typ,
		Note: note,
	}
}
