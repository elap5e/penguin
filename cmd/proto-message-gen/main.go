// Copyright 2022 Elapse and contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

type Message struct {
	Name    string     `json:"name,omitempty"`
	Note    string     `json:"note,omitempty"`
	Source  string     `json:"source,omitempty"`
	Length  int        `json:"length,omitempty"`
	Fields  []*Field   `json:"fields,omitempty"`
	Message []*Message `json:"message,omitempty"`
}

type Field struct {
	Code uint64 `json:"code,omitempty"`
	Name string `json:"name,omitempty"`
	Type string `json:"type,omitempty"`
	Note string `json:"note,omitempty"`
}

func main() {
	filepath.Walk(".", func(file string, info os.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}
		if strings.HasSuffix(info.Name(), ".pb.java") {
			dir := path.Dir(file)
			dst := dir + "/" + strings.ReplaceAll(info.Name(), ".pb.java", ".proto")
			data, err := ioutil.ReadFile(file)
			if err != nil {
				log.Fatalln(err)
			}
			lines := strings.Split(string(data), "\n")
			index := strings.Index(lines[0], "package")
			if index == -1 {
				log.Fatalln("package not found")
			}
			message, _ := parseMessage(index, lines)
			if len(message.Fields) == 0 && len(message.Message) == 1 {
				source := message.Source
				message = message.Message[0]
				message.Source = source
			}
			buf := bytes.NewBuffer(nil)
			buf.WriteString("syntax = \"proto3\";\n")
			buf.WriteString("\n")
			buf.WriteString("option go_package = \"github.com/elap5e/penguin/" + dir + "\";\n")
			buf.WriteString("\n")
			buf.WriteString("// Message generated by proto-message-gen. DO NOT EDIT.\n")
			buf.WriteString("// source: " + message.Source + "." + message.Note + "\n")
			buf.WriteString("//\n")
			writeMessage(buf, 0, message)
			if err := ioutil.WriteFile(dst, buf.Bytes(), 0644); err != nil {
				log.Fatalln(err)
			}
		}
		return nil
	})
}

func writeMessage(buf *bytes.Buffer, index int, message *Message) {
	blank := strings.Repeat(" ", index)
	buf.WriteString(blank + "// " + message.Name + " is the message type for the " + message.Note + ".\n")
	if len(message.Fields) != 0 || len(message.Message) != 0 {
		buf.WriteString(blank + "message " + message.Name + " {\n")
		for _, v := range message.Fields {
			format := fmt.Sprintf("%%s  %%-%ds = %%d; // %%s\n", message.Length)
			buf.WriteString(fmt.Sprintf(format, blank, v.Type+" "+v.Name, v.Code, v.Note))
		}
		for _, v := range message.Message {
			writeMessage(buf, index+2, v)
		}
		buf.WriteString(blank + "}\n")
	} else {
		buf.WriteString(blank + "message " + message.Name + " {}\n")
	}
}

func parseMessage(index int, lines []string) (*Message, int) {
	var line, name string
	var msg *Message
	var codes map[string]uint64
	for i := 0; i < len(lines); i++ {
		if line = lines[i]; len(line) > index {
			line = strings.TrimSpace(line[index:])
			if strings.HasPrefix(line, "package") {
				name = strings.Split(line, " ")[1]
				name = name[:len(name)-1]
			} else if strings.HasPrefix(line, "public final class") || strings.HasPrefix(line, "public static final class") {
				if msg == nil {
					msg = new(Message)
					msg.Note = strings.Split(line, " ")[3]
					if msg.Note == "class" {
						msg.Note = strings.Split(line, " ")[4]
					}
					msg.Name = parseName(msg.Note)
					msg.Source = name
				} else {
					emb, n := parseMessage(index, lines[i:])
					msg.Message = append(msg.Message, emb)
					i = i + n
				}
			} else if strings.HasPrefix(line, "static final MessageMicro.FieldMap") {
				tmp := strings.Split(line, "(new int[]{")
				if len(tmp) == 1 {
					continue
				}
				tmp = strings.Split(tmp[1], "}, new String[]{")
				strs := strings.Split(tmp[0], ", ")
				tmp = strings.Split(tmp[1], "}, new Object[]{")
				codes = make(map[string]uint64)
				for k, v := range strings.Split(tmp[0], ", ") {
					codes[strings.ReplaceAll(v, "\"", "")], _ = strconv.ParseUint(strs[k], 10, 64)
				}
			} else if strings.HasPrefix(line, "public") {
				tmp := strings.Split(line, " ")[1:]
				if tmp[0] == "final" {
					tmp = tmp[1:]
				}
				if code := codes[tmp[1]]; code != 0 {
					field := parseField(code, tmp[1], tmp[0])
					msg.Fields = append(msg.Fields, field)
					length := len(field.Name) + len(field.Type) + 1
					if length > msg.Length {
						msg.Length = length
					}
				}
			} else if !strings.HasPrefix(line, "}") {
			} else {
				return msg, i
			}
		}
	}
	return msg, 0
}

func parseName(name string) string {
	return name
}

func parseField(code uint64, name, typ string) *Field {
	note := name
	if typ == "PBBoolField" {
		typ = "bool"
	} else if typ == "PBBytesField" {
		typ = "bytes"
	} else if typ == "PBFixed32Field" {
		typ = "fixed32"
	} else if typ == "PBFixed64Field" {
		typ = "fixed64"
	} else if typ == "PBFloatField" {
		typ = "float"
	} else if typ == "PBInt32Field" {
		typ = "int32"
	} else if typ == "PBInt32Field" {
		typ = "int32"
	} else if typ == "PBSInt32Field" {
		typ = "sint32"
	} else if typ == "PBSInt32Field" {
		typ = "sint32"
	} else if typ == "PBStringField" {
		typ = "string"
	} else if typ == "PBUInt32Field" {
		typ = "uint32"
	} else if typ == "PBUInt64Field" {
		typ = "uint64"
	} else if strings.HasPrefix(typ, "PBRepeatField") {
		re, _ := regexp.Compile("PBRepeatField<(.*)>")
		switch tmp := re.FindStringSubmatch(typ)[1]; tmp {
		case "ByteStringMicro":
			typ = "bytes"
		case "Integer":
			typ = "uint32"
		case "Float":
			typ = "float"
		case "Long":
			typ = "uint64"
		case "String":
			typ = "string"
		}
		typ = "repeated " + typ
	} else if strings.HasPrefix(typ, "PBRepeatMessageField") {
		re, _ := regexp.Compile("PBRepeatMessageField<(.*)>")
		typ = "repeated " + re.FindStringSubmatch(typ)[1]
	}
	strs := strings.Split(name, "_")
	for {
		if len(strs) == 1 {
			break
		}
		if strs[0] == "" ||
			strs[0] == "bool" ||
			strs[0] == "bytes" ||
			strs[0] == "fixed32" ||
			strs[0] == "fixed64" ||
			strs[0] == "int32" ||
			strs[0] == "int64" ||
			strs[0] == "rpt" ||
			strs[0] == "str" ||
			strs[0] == "string" ||
			strs[0] == "sint32" ||
			strs[0] == "sint64" ||
			strs[0] == "uint32" ||
			strs[0] == "uint64" {
			strs = strs[1:]
		} else if strs[0] == "opt" {
			typ = "optional " + typ
			strs = strs[1:]
		} else {
			break
		}
	}
	name = strings.Join(strs, "_")
	return &Field{
		Code: code >> 3,
		Name: name,
		Type: typ,
		Note: note,
	}
}
